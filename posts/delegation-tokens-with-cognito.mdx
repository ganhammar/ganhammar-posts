---
title: Delegation Tokens with Amazon Cognito
id: delegation-tokens-with-cognito
date: 2023-12-23
---

# Delegation Tokens with Amazon Cognito

The Delegation or On-Behalf-Of (OBO) flow is used when a service, often an API, needs to perform an action, often calling another API, on behalf of the end-user. This to ensure that the end-user has the permissions required to perform the action in the target service. The flow is not a part of the original OAuth 2.0 specification (RFC 6749), it is an extension introduced by Microsoft.

How the flow works:

1. The client (an application that interacts with the end-user, e.g a web or mobile application) autenticates the end-user and obtains an access token from the authorization server.
2. The client calls the initial API, API A, passing along the access token.
3. The access token is only scoped to be able to call API A, therefore the API needs to request a new access token which is scoped to call the second API, API B. To ensure that the end-user also has the correct permissions to call API B, it passes along the original access token.
4. The authorization server validates the incoming token and the clients credentials, and issues a new access token.
5. API A uses this new access token to call API B, which is then scoped to be able to access API B and based on the end-users permissions.

# Implementation, the Cognito Way 

Amazon Cognito does not support this flow out-of-the box, however, they do support custom authentication flows, which we can use for our solution. Custom authentication flows are defined using AWS Lambda triggers. These triggers can be used to add custom validation, challenges for the user, such as additional authentication factors, or even to integrate with external systems.

The triggers are:

1. **Define Auth Challenge** which is used to determine the next challenge in a custom auth flow, such as asking the user for additional information, or calling an external system.
2. **Create Auth Challenge** which is used to create a custom auth challenge for the end-user, based on the session information and the challenge name. Such as emailing a one-time password, which is also passed down stream to Cognito.
3. **Verify Auth Challenge** which is used to determine if the response is correct. In the one-time password example, it verifies that the answer from the end-user matches what was passed down stream.

We can use this custom authentication flow to implement the delegation flow. We utilize the Define Auth Challenge lambda to return a DELEGATION challenge for the end-user and the Verify Auth Challenge lambda to verify that the answer contains a valid JWT.

The problem with the custom auth flow is that we cannot request any scope(s) with the token request, but it is possible to pass client metadata with the request. We can use this parameter together with the Cognito trigger "Pre Token Generation", which can be used to add or remove claims and scopes, to add the necissary scopes required in order to call API B. As of a week ago, we can use this trigger to also modify the access token properties (which requires Cognito Advanced Security).

## Defining the Stack

We will use CDK to define our stack, I will focus on the parts essential for this solution, the complete example can be found [here](https://github.com/ganhammar/delegation-with-amazon-cognito).

Let's start with creating a new CDK project by running `cdk init app --language typescript` in an empty folder called "delegation" and edit the `delegation-stack.ts`-file to add a UserPool and enable advanced security mode:

```typescript
// Create user pool
const userPool = new UserPool(this, "UserPool", {
  userPoolName: "delegation",
  customAttributes: {
    permission: new StringAttribute({ mutable: true }),
  },
});

userPool.addDomain("UserPoolDomain", {
  cognitoDomain: {
    domainPrefix: "delegation",
  },
});

// Enable advanced security
const cfnUserPool = userPool.node.defaultChild as CfnUserPool;
cfnUserPool.userPoolAddOns = {
  advancedSecurityMode: "ENFORCED",
};

// Store user pool id in SSM, to be used by Lambda integrations
new StringParameter(this, "UserPoolIdParameter", {
  parameterName: "/delegation/userpool/id",
  stringValue: userPool.userPoolId,
});
```

Then we will add a resource server to manage the scopes required to access our different services, in this example I will add a booking service and a review service.

```typescript
// Add resource server
const resourceServer = userPool.addResourceServer("ResourceServer", {
  identifier: "resources",
  scopes: [
    {
      scopeName: "booking-service",
      scopeDescription: "Access booking service",
    },
    {
      scopeName: "review-service",
      scopeDescription: "Access review service",
    },
  ],
});
```

Next we will define Pre Token Generation Lambda (pre-token-generation.ts), which we store in a new folder called `handlers` in the `lib`-folder. The type definitions for Pre Token Generation V2 has not yet been included in the `aws-lambda`-package, so it must be manually defined, they can be found [here](https://github.com/ganhammar/delegation-with-amazon-cognito/blob/main/lib/handlers/pre-token-generation.ts). I have excluded them in the below code:

```typescript
export const handler = async (event: PreTokenGenerationTriggerHandler) => {
  const scopesToAdd = [];

  // Check if the clientMetadata property is set and contains scope
  if (event.request?.clientMetadata?.scope) {
    const scopes = event.request.clientMetadata.scope.split(" ");

    // Verify that the client actually has access to the requested scope(s)
    const cognitoClient = new CognitoIdentityProviderClient({
      region: "eu-north-1",
    });

    const region = process.env.AWS_REGION!;
    const ssmClient = new SSMClient({ region });
    const ssmCommand = new GetParameterCommand({
      Name: "/delegation/userpool/id",
    });
    const userPoolId = (await ssmClient.send(ssmCommand)).Parameter!.Value!;

    const command = new DescribeUserPoolClientCommand({
      UserPoolId: userPoolId,
      ClientId: event.callerContext.clientId,
    });

    const data = await cognitoClient.send(command);

    const clientScopes = data.UserPoolClient?.AllowedOAuthScopes || [];

    for (const scope of scopes) {
      if (clientScopes.includes(scope)) {
        scopesToAdd.push(event.request.clientMetadata.scope);
      }
    }
  }

  event.response = {
    claimsAndScopeOverrideDetails: {
      idTokenGeneration: {
        scopesToAdd,
      },
      accessTokenGeneration: {
        scopesToAdd,
      },
    },
  };

  return event;
};
```

Then we will continue to update our stack and add the Pre Token Generation trigger:

```typescript
// Define pre token generation lambda
const preTokenGeneration = new NodejsFunction(this, "PreTokenGeneration", {
  runtime: Runtime.NODEJS_20_X,
  handler: "handler",
  entry: `${__dirname}/handlers/pre-token-generation.ts`,
  memorySize: 1769,
});

preTokenGeneration.addToRolePolicy(
  new PolicyStatement({
    actions: ["ssm:GetParameter"],
    resources: [
      Stack.of(this).formatArn({
        service: "ssm",
        resource: "parameter/delegation/userpool/id",
      }),
    ],
  }),
);

preTokenGeneration.addToRolePolicy(
  new PolicyStatement({
    actions: ["cognito-idp:DescribeUserPoolClient"],
    resources: ["*"],
  })
);

userPool.addTrigger(
  UserPoolOperation.PRE_TOKEN_GENERATION,
  preTokenGeneration
); // Needs to be changed to V2_0 in console until CDK supports it
```

Next we will define the Define Auth Challenge Lambda in the same folder as our other handler:

```typescript
import { Callback, Context, DefineAuthChallengeTriggerEvent } from "aws-lambda";

exports.handler = function (
  event: DefineAuthChallengeTriggerEvent,
  _: Context,
  callback: Callback
) {
  if (event.request.session.length === 0) {
    // If it's the first sign in attempt, present the password verifier challenge
    event.response.issueTokens = false;
    event.response.failAuthentication = false;
    event.response.challengeName = "DELEGATION";
  } else if (
    event.request.session.length === 1 &&
    event.request.session[0].challengeResult === true
  ) {
    // If the password verifier returns a successful result, issue tokens
    event.response.issueTokens = true;
    event.response.failAuthentication = false;
  } else {
    // If the password verifier returns a failed result, fail authentication
    event.response.issueTokens = false;
    event.response.failAuthentication = true;
  }

  callback(null, event);
};
```

And update our stack to connect the handler with the UserPool:

```typescript
// Define auth challenge lambda
const defineAuthChallenge = new NodejsFunction(
  this,
  "DefineAuthChallenge",
  {
    runtime: Runtime.NODEJS_20_X,
    handler: "handler",
    entry: `${__dirname}/handlers/define-auth-challenge.ts`,
    memorySize: MEMORY_SIZE,
  }
);

userPool.addTrigger(
  UserPoolOperation.DEFINE_AUTH_CHALLENGE,
  defineAuthChallenge
);
```
