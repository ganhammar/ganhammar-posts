---
title: Fine Grained Authorization with Amazon Cognito
id: fine-grained-authorization-with-amazon-cognito
date: 2023-12-27
status: draft
---

# Fine Grained Authorization with Amazon Cognito

[As of a week ago](https://aws.amazon.com/about-aws/whats-new/2023/12/amazon-cognito-user-pools-customize-access-tokens/), you can now modify the contents of the access token, making it possible to add fine grained authorization decisions to your application that is leveraging Amazon Cognito for user authentication. Previously it has only been possible to modify the contents of the id token, which should soly be used to authenticate the user, not to authorize operations. This is what the access token is for. Modifying the properties of the access token requires that the User Pool is configured to enforce Advanced Security.

## Amazon Cognito Lambda Triggers

Amazon Cognito has support for [different Lambda triggers](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html) that can be used to customize the behavior of a user pool at various points in the authentication and authorization process. In [my previous post](https://www.ganhammar.se/posts/delegation-tokens-with-cognito), I explained how some of these triggers can be used to implement the delegation (or on-behalf-of) flow using Amazon Cognito, one of the triggers used in that solution is the "Pre Token Generation" trigger. This trigger can be used to add or remove properties of the id and access token, which is exactly what we need to be able to implement fine grained authorization in our application.

## Structuing the Permissions

In order to keep the id and access token relatively slim, we need to ensure that we only add the permissions valid for the current authorization context, based on the client that is requesting the token. In this example we will work with a booking application, the solution will contain two different domains, one that handles booking and one that handles reviews. When our front end application requests an access token for the end user, we know that it will only communicate with the booking services, not with the review service, therefore we only need to add permissions relevant to that domain.

We also know that there will likely be a lot of users using our application over time, therefore we need to ensure that we have a easy way to manage the permissions for our user base, we can't add and remove permissions on each and every user, instead we need a role-concept. We bind permissions to roles rather than to the users directly. Amazon Cognito has a user group concept that we can utilize for this use case, users of the group "User" gets a certain list of permissions and users of the group "Admin" gets another.

Based on this, this is how we will structure our permissions for this solution:

| Client | Role | Permissions |
|-------|-------|-------|
| BookingFrontClient | Admin | booking:read, booking:write, booking:delete |
| BookingFrontClient | User | booking:read |
| BookingServiceClient | Admin | review:read, review:write, review:delete |
| BookingServiceClient | User | review:read |

# Implementation

We will use CDK to define our stack, I will focus on the parts essential for this solution, the complete example can be found [here](https://github.com/ganhammar/fine-grained-permissions-with-amazon-cognito).

Let's start with creating a new CDK project by running `cdk init app --language typescript` in an empty folder called "permissions" and edit the `permissions-stack.ts`-file to add a UserPool and enable advanced security mode:

```typescript
// Create user pool
const userPool = new UserPool(this, "UserPool", {
  userPoolName: "delegation",
  customAttributes: {
    permission: new StringAttribute({ mutable: true }),
  },
});

userPool.addDomain("UserPoolDomain", {
  cognitoDomain: {
    domainPrefix: "delegation",
  },
});

// Enable advanced security
const cfnUserPool = userPool.node.defaultChild as CfnUserPool;
cfnUserPool.userPoolAddOns = {
  advancedSecurityMode: "ENFORCED",
};

// Store user pool id in SSM, to be used by Lambda integrations
new StringParameter(this, "UserPoolIdParameter", {
  parameterName: "/delegation/userpool/id",
  stringValue: userPool.userPoolId,
});
```

Then we will add a resource server to manage the scopes required to access our different services, as mentioned, in this example I will add a booking service and a review service.

```typescript
// Add resource server
const resourceServer = userPool.addResourceServer("ResourceServer", {
  identifier: "resources",
  scopes: [
    {
      scopeName: "booking-service",
      scopeDescription: "Access booking service",
    },
    {
      scopeName: "review-service",
      scopeDescription: "Access review service",
    },
  ],
});
```

Next, we will define Pre Token Generation Lambda (pre-token-generation.ts), which we store in a new folder called `handlers` in the `lib`-folder. The type definitions for Pre Token Generation V2 have not yet been included in the `aws-lambda`-package, so it must be manually defined, they can be found [here](https://github.com/ganhammar/fine-grained-permissions-with-amazon-cognito/blob/main/lib/handlers/pre-token-generation.ts). I have excluded them in the below code:
